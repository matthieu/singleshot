h1.  Access Control and Security

This section deals with people, authentication, authorization and all other manners of security.


h2.  People

Every person is represented with a record in the database (the @persons@ table).  The minimum information we need to know about each person is their identity (lookup and reference), full name (display), e-mail address (notifications), preferred language and current timezone.

The implementation uses nicknames for identity.  You can change the implementation to use other forms of identity (e.g. OpenID URLs) by changing @Person.identify@ and @Person.to_param@ respectively.  It also uses nicknames as login names that in combination with passwords are used for HTTP Basic and session authentication.  You can change this behavior or implement other authentication mechanisms by changing @Person.authenticate@.

The last piece of information we use is the site_url, which if specified will link to that person's HTML page.

Storing information about people externally (e.g. LDAP directory, OpenID server) is possible with the following constraints.  You can replace the way @Person@ retrieves, updates and authenticates people in the system, but you need to maintain at least a skeleton record referencing those external resource.  Other records reference people internally through their primary key.


h2.  Authentication

Singleshot requires at least four different methods of authentication, depending on the type of access.  Username/password authentication (HTTP Basic and Sessions) is built into the system, but doesn't preclude the use of external mechanisms such as Single Sign-on, OpenID and OAuth.

*HTTP Basic*  The REST API uses HTTP Basic Authentication.  HTTP Basic is generally easier to use and more widely supported than HTTP Digest.  Passing sensitive information in clear text is a concern but not a reason for using HTTP Digest; use HTTPS to secure all information transmitted over the wire.

Passwords are salted and stored as SHA1 digests of the password/salt combination, along with the salt.

*Sessions*  HTTP Authentication is not particularly user friendly.  The presentation of the authentication dialog box is inconsistent with the rest of the application, and provides no relevant links for registration, retrieving lost passwords or using alternative authentication mechanisms (such as OpenID).  It also does not integrate with single sign-on.

Browsers authenticate through several mechanisms that eventually associate a particular user with the current session and maintain that authentication using session cookies.  The current mechanism uses login name and password.

*Access key*  Feed readers and calendars can't use either scheme.  Some do allow you to use URLs that contain authentication information (username and password), but those are not implemented consistently, and further risks exposing your credentials.  Instead we use an access key generated for each account.  This access key is used as a query string parameter to grant read-only (GET) access to the resource.

Resources that support the access key create their URLs using @access_key_authentication_parameters@ and authenticate using @authenticate_using_access_key@.  To deal with compromised access keys, reset the person's access key by calling @Person.access_key!@.

*Tokens*  To view and perform the task, the application also needs to access the task state.  Again we have no way of passing credentials around, and instead use unique tokens to grant access to the individual task and stakeholder. 

*OpenID and OAuth*  TBD.

*Single Sign-on*  TBD.


h2.  Authorization

A task is associated with stakeholders, stakeholders are people related to the task through a specific role.  For example, any stakeholder of the task can view it, but only the owner can perform it; potential owners are allowed to claim the task, the owner is allowed to delegate, and so forth.  Authorization is based on these stakeholders and the capabilities granted to each role.

One role is that of an administrator, and each task has at least one administrator established when creating that task.  For convenience, we also maintain a global list of administrators associated with all tasks through @Task.admins@.


